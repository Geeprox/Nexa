name: CI Auto Fix

on:
  workflow_run:
    workflows:
      - CI
    types:
      - completed

permissions:
  actions: read
  contents: write
  pull-requests: write

concurrency:
  group: ci-autofix-${{ github.event.workflow_run.id }}
  cancel-in-progress: true

jobs:
  autofix:
    if: >
      github.event.workflow_run.conclusion == 'failure' &&
      github.event.workflow_run.event == 'push' &&
      github.event.workflow_run.head_branch == 'main'
    runs-on: ubuntu-latest
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      OPENAI_MODEL: ${{ vars.CI_AUTOFIX_MODEL || 'gpt-4.1' }}
      CI_FAILED_RUN_ID: ${{ github.event.workflow_run.id }}
      CI_FAILED_RUN_URL: ${{ github.event.workflow_run.html_url }}
      CI_FAILED_HEAD_SHA: ${{ github.event.workflow_run.head_sha }}
    steps:
      - name: Checkout failed commit
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: Detect failed jobs
        id: failed_jobs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const runId = context.payload.workflow_run.id;
            const jobs = await github.paginate(
              github.rest.actions.listJobsForWorkflowRun,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: runId,
                per_page: 100
              }
            );
            const failed = jobs.filter((job) => job.conclusion === "failure");
            const names = failed.map((job) => job.name);
            const hasWebFailure = names.includes("Web Quality");
            core.setOutput("web_quality_failed", hasWebFailure ? "true" : "false");
            core.setOutput("failed_job_names", names.join(", "));
            core.info(`Failed jobs: ${names.join(", ") || "(none)"}`);

      - name: Stop when no Web Quality failure
        if: steps.failed_jobs.outputs.web_quality_failed != 'true'
        run: |
          echo "Skipping auto-fix because Web Quality did not fail."
          echo "Failed jobs: ${{ steps.failed_jobs.outputs.failed_job_names }}"

      - name: Setup Node.js
        if: steps.failed_jobs.outputs.web_quality_failed == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Setup Rust
        if: steps.failed_jobs.outputs.web_quality_failed == 'true'
        uses: dtolnay/rust-toolchain@stable

      - name: Install dependencies
        if: steps.failed_jobs.outputs.web_quality_failed == 'true'
        run: npm ci

      - name: Reproduce failure locally
        if: steps.failed_jobs.outputs.web_quality_failed == 'true'
        id: reproduce
        run: |
          mkdir -p .autofix

          run_capture() {
            local name="$1"
            shift
            local log_file=".autofix/${name}.log"
            local exit_file=".autofix/${name}.exit"
            set +e
            "$@" >"$log_file" 2>&1
            local status="$?"
            set -e
            printf "%s" "$status" >"$exit_file"
          }

          run_capture npm-test npm test
          run_capture npm-build npm run build
          run_capture cargo-build cargo build --manifest-path src-tauri/Cargo.toml

          echo "test_exit=$(cat .autofix/npm-test.exit)" >> "$GITHUB_OUTPUT"
          echo "build_exit=$(cat .autofix/npm-build.exit)" >> "$GITHUB_OUTPUT"
          echo "cargo_exit=$(cat .autofix/cargo-build.exit)" >> "$GITHUB_OUTPUT"

      - name: Generate and apply patch via OpenAI
        if: >
          steps.failed_jobs.outputs.web_quality_failed == 'true' &&
          env.OPENAI_API_KEY != ''
        id: generate_fix
        run: |
          node ./scripts/ci/openai-autofix.mjs
          APPLIED="$(node -e "const fs=require('fs');const p='.autofix/result.json';if(!fs.existsSync(p)){process.stdout.write('false');process.exit(0)};const r=JSON.parse(fs.readFileSync(p,'utf8'));process.stdout.write(r.applied?'true':'false');")"
          REASON="$(node -e "const fs=require('fs');const p='.autofix/result.json';if(!fs.existsSync(p)){process.stdout.write('no_result');process.exit(0)};const r=JSON.parse(fs.readFileSync(p,'utf8'));process.stdout.write(String(r.reason||'applied'));")"
          echo "applied=$APPLIED" >> "$GITHUB_OUTPUT"
          echo "reason=$REASON" >> "$GITHUB_OUTPUT"

      - name: Skip when OPENAI_API_KEY is missing
        if: >
          steps.failed_jobs.outputs.web_quality_failed == 'true' &&
          env.OPENAI_API_KEY == ''
        run: echo "OPENAI_API_KEY is missing; skip auto-fix patch generation."

      - name: Verify patch
        if: steps.generate_fix.outputs.applied == 'true'
        id: verify
        continue-on-error: true
        run: |
          npm test
          npm run build
          cargo build --manifest-path src-tauri/Cargo.toml

      - name: Create auto-fix PR
        if: >
          steps.generate_fix.outputs.applied == 'true' &&
          steps.verify.outcome == 'success'
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "fix(ci): auto-fix for failed run #${{ github.event.workflow_run.id }}"
          branch: "codex/ci-autofix-${{ github.event.workflow_run.id }}"
          delete-branch: true
          title: "fix(ci): auto-fix for CI run #${{ github.event.workflow_run.id }}"
          body: |
            This PR was generated automatically for a failed CI run.

            - Failed run: ${{ github.event.workflow_run.html_url }}
            - Base commit: `${{ github.event.workflow_run.head_sha }}`
            - Failed jobs: `${{ steps.failed_jobs.outputs.failed_job_names }}`

            Validation performed in auto-fix workflow:
            - `npm test`
            - `npm run build`
            - `cargo build --manifest-path src-tauri/Cargo.toml`

            Please review carefully before merging.

      - name: Upload auto-fix diagnostics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ci-autofix-${{ github.event.workflow_run.id }}
          path: .autofix
          if-no-files-found: ignore
